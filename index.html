<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VEX Path Planner - Pro Editor v45 (Dynamic Alignment)</title>
    <link rel="icon" href="ibb_logo_favicon.jpg" type="image/jpeg" />
    <style>
      /* GENEL SAYFA DÃœZENÄ° */
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #1e1e1e;
        color: #ccc;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 0;
        margin: 0;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
      }

      h1 {
        color: #fff;
        margin: 10px 0 5px 0;
        font-size: 1.4rem;
        flex-shrink: 0;
      }

      /* DOSYA MENÃœSÃœ */
      .file-menu-container {
        position: absolute;
        top: 15px;
        left: 15px;
        z-index: 100;
      }

      /* SAÄž ÃœST LOGO STÄ°LÄ° */
      .top-right-logo {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 60px;
        height: auto;
        z-index: 100;
        border-radius: 5px;
      }

      .dropbtn {
        background-color: #007bff;
        color: white;
        padding: 10px 20px;
        font-size: 14px;
        border: none;
        cursor: pointer;
        border-radius: 5px;
        font-weight: bold;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      }

      .dropdown {
        position: relative;
        display: inline-block;
      }
      .dropdown-content {
        display: none;
        position: absolute;
        background-color: #2d2d2d;
        min-width: 160px;
        box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
        z-index: 1;
        border-radius: 5px;
        border: 1px solid #444;
      }
      .dropdown-content a {
        color: #ccc;
        padding: 12px 16px;
        text-decoration: none;
        display: block;
        font-size: 13px;
        cursor: pointer;
      }
      .dropdown-content a:hover {
        background-color: #444;
        color: #fff;
      }
      .dropdown:hover .dropdown-content {
        display: block;
      }
      .dropdown:hover .dropbtn {
        background-color: #0056b3;
      }

      /* YAN YANA DÃœZEN Ä°Ã‡Ä°N CSS (FLEX) */
      .setting-group-inline {
        background: #333;
        padding: 8px;
        border-radius: 6px;
        display: flex;
        justify-content: space-between; /* YazÄ± solda, input saÄŸda */
        align-items: center;
        margin-bottom: 8px;
      }
      .setting-group-inline label {
        margin: 0;
        font-size: 0.85rem;
        color: #aaa;
        white-space: nowrap; /* YazÄ± alt satÄ±ra geÃ§mesin */
        margin-right: 10px;
      }
      .setting-group-inline input[type="number"],
      .setting-group-inline input[type="text"] {
        width: 80px !important; /* GeniÅŸliÄŸi sabitle */
        background: #444;
        border: 1px solid #555;
        color: #fff;
        padding: 4px;
        border-radius: 4px;
        text-align: center;
        box-sizing: border-box;
      }

      /* TOGGLE BUTON STÄ°LÄ° (Tek Buton) - SOL MENÃœ (PEMBE) */
      .toggle-action-btn.mech-btn {
        width: 80px;
        background-color: #d63384; /* Pembe */
        color: white;
        border: none;
        padding: 5px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.8rem;
        font-weight: bold;
        transition: 0.2s;
        text-align: center;
      }
      .toggle-action-btn.mech-btn:hover {
        background-color: #c22e76;
      }

      /* TOGGLE BUTON STÄ°LÄ° (Tek Buton) - SAÄž MENÃœ (TURUNCU) */
      #pointDirBtn {
        width: 80px;
        background-color: #fd7e14; /* Turuncu */
        color: white;
        border: none;
        padding: 5px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.8rem;
        font-weight: bold;
        transition: 0.2s;
        text-align: center;
      }
      #pointDirBtn:hover {
        background-color: #e36e0e;
      }

      /* AYIRICI Ã‡Ä°ZGÄ° */
      .setting-group-separator {
        border-bottom: 1px solid #444;
        margin-bottom: 10px;
        padding-bottom: 10px;
      }

      /* ROBOT SÄ°MÃœLASYON MENÃœSÃœ */
      .left-sidebar {
        width: 240px;
        height: 100%;
        background-color: #252526;
        border: 1px solid #3e3e42;
        border-radius: 8px;
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        box-sizing: border-box;
        flex-shrink: 0;
        overflow-y: auto;
      }
      .left-sidebar h3 {
        margin: 10px 0 5px 0;
        font-size: 0.95rem;
        color: #d63384;
        border-bottom: 1px solid #444;
        padding-bottom: 5px;
        text-align: center;
      }

      /* PLAY BUTONU */
      .play-btn {
        background-color: #28a745;
        color: white;
        flex: none !important;
        height: 32px;
        padding: 0 10px;
        font-size: 0.8rem;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        width: 100%;
        margin-top: auto;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 5px;
      }
      .play-btn:hover {
        background-color: #218838;
      }
      .play-btn.playing {
        background-color: #dc3545;
      }
      .play-btn.playing:hover {
        background-color: #c82333;
      }

      /* ÃœST KONTROL BAR */
      .top-controls {
        background: #2d2d2d;
        padding: 8px 20px;
        border-radius: 8px;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 15px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        z-index: 10;
        flex-shrink: 0;
      }

      .top-controls label {
        font-weight: bold;
        color: #fff;
        font-size: 13px;
      }
      .top-controls input[type="number"],
      .top-controls input[type="text"] {
        background: #444;
        border: 1px solid #555;
        color: #fff;
        padding: 4px;
        border-radius: 4px;
        width: 60px;
        text-align: center;
      }
      .top-controls input:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* TOGGLE SWITCH */
      .switch-container {
        display: flex;
        align-items: center;
        gap: 8px;
        background: #383838;
        padding: 6px 12px;
        border-radius: 20px;
        justify-content: space-between;
      }
      .switch {
        position: relative;
        display: inline-block;
        width: 36px;
        height: 18px;
      }
      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 20px;
      }
      .slider:before {
        position: absolute;
        content: "";
        height: 14px;
        width: 14px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }
      input:checked + .slider {
        background-color: #007bff;
      }
      input:checked + .slider.green {
        background-color: #28a745;
      }
      input:checked + .slider.pink {
        background-color: #d63384;
      }
      input:checked + .slider.orange {
        background-color: #fd7e14;
      }
      input:checked + .slider:before {
        transform: translateX(18px);
      }

      /* ANA DÃœZEN */
      .main-layout {
        display: flex;
        gap: 15px;
        justify-content: center;
        align-items: center;
        height: calc(100vh - 120px);
        width: 98%;
        padding-bottom: 10px;
        box-sizing: border-box;
      }

      .canvas-wrapper {
        position: relative;
        border: 4px solid #444;
        width: 600px;
        height: 600px;
        flex-shrink: 0;
        cursor: crosshair;
        margin: auto 0;
      }
      canvas {
        position: absolute;
        top: 0;
        left: 0;
      }

      .settings-panel {
        width: 250px;
        background-color: #252526;
        border: 1px solid #3e3e42;
        border-radius: 8px;
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        height: 100%;
        box-sizing: border-box;
        overflow-y: auto;
        flex-shrink: 0;
      }
      .settings-panel h3 {
        margin: 0;
        font-size: 1rem;
        color: #ff9f43;
        text-align: center;
        border-bottom: 1px solid #444;
        padding-bottom: 5px;
      }
      .setting-group {
        background: #333;
        padding: 8px;
        border-radius: 6px;
      }
      .setting-group label {
        display: block;
        font-size: 0.85rem;
        color: #aaa;
        margin-bottom: 4px;
      }

      .coord-inputs {
        display: flex;
        gap: 5px;
        align-items: center;
      }
      .coord-inputs input {
        width: 100%;
        background: #222;
        border: 1px solid #555;
        color: #fff;
        padding: 3px;
        text-align: center;
        font-family: monospace;
      }

      .angle-control {
        display: flex;
        align-items: center;
        gap: 5px;
        margin-bottom: 5px;
      }
      .angle-buttons {
        display: flex;
        gap: 5px;
        margin-top: 5px;
      }
      .angle-buttons button {
        padding: 4px;
        font-size: 0.8rem;
        background-color: #555;
      }

      .full-width-input {
        width: 95%;
        background: #222;
        border: 1px solid #555;
        color: #fff;
        padding: 4px;
        margin-top: 2px;
      }
      select {
        width: 100%;
        background: #222;
        border: 1px solid #555;
        color: #fff;
        padding: 4px;
        border-radius: 4px;
      }

      /* KNOB CSS */
      .knob-wrapper {
        display: flex;
        justify-content: center;
        margin: 10px 0;
      }
      .knob-container {
        position: relative;
        width: 100px;
        height: 100px;
        background-color: #222;
        border-radius: 50%;
        box-shadow: inset 0 0 10px #000;
        display: flex;
        justify-content: center;
        align-items: center;
        border: 1px solid #444;
      }
      .knob-track {
        position: absolute;
        width: 85%;
        height: 85%;
        border-radius: 50%;
        border: 4px solid #444;
        box-sizing: border-box;
      }
      .handle-rotator {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        transform-origin: center center;
        pointer-events: none;
        transform: rotate(0deg);
      }

      .knob-handle {
        position: absolute;
        width: 18px;
        height: 18px;
        background-color: #ff9f43;
        border-radius: 50%;
        border: 2px solid #fff;
        left: 50%;
        top: 50%;
        transform: translate(calc(-50% + 40.5px), -50%);
        cursor: grab;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        pointer-events: auto;
        transition: background-color 0.2s;
      }

      .knob-handle::after {
        content: "";
        position: absolute;
        left: 100%;
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border-top: 6px solid transparent;
        border-bottom: 6px solid transparent;
        border-left: 8px solid #ff9f43;
      }

      .knob-handle:active {
        cursor: grabbing;
        background-color: #e67e22;
      }
      .knob-handle:active::after {
        border-left-color: #e67e22;
      }

      /* --------------------------- */

      /* SAÄž PANEL */
      .output-panel {
        width: 260px;
        background-color: #2d2d2d;
        padding: 10px;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        height: 100%;
        box-sizing: border-box;
        flex-shrink: 0;
      }
      .tools-menu {
        background: #333;
        padding: 8px;
        border-radius: 5px;
        display: flex;
        gap: 5px;
        justify-content: space-around;
      }
      .tool-btn {
        background: #444;
        font-size: 0.8rem;
        padding: 5px;
      }
      textarea {
        flex-grow: 1;
        background-color: #111;
        color: #569cd6;
        border: 1px solid #555;
        padding: 8px;
        font-family: "Consolas", "Courier New", monospace;
        font-size: 11px;
        white-space: pre;
        resize: none;
      }
      .btn-group {
        display: flex;
        gap: 5px;
      }
      button {
        padding: 8px;
        flex: 1;
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
        border-radius: 4px;
        font-weight: bold;
        transition: 0.2s;
      }
      button:hover {
        background-color: #0056b3;
      }
      button.clear {
        background-color: #dc3545;
      }
      button.clear:hover {
        background-color: #a71d2a;
      }
      button.undo {
        background-color: #ffc107;
        color: #333;
      }
      button.delete-pt {
        background-color: #dc3545;
        color: #fff;
        margin-top: 5px;
        width: 100%;
      }
    </style>
  </head>
  <body>
    <img src="ibb_logo.jpg" alt="Ä°BB Tech Logo" class="top-right-logo" />
    <div class="file-menu-container">
      <div class="dropdown">
        <button class="dropbtn">Dosya</button>
        <div class="dropdown-content">
          <a onclick="savePath()">ðŸ’¾ Projeyi Kaydet</a>
          <a onclick="document.getElementById('fileInput').click()"
            >ðŸ“‚ Proje YÃ¼kle</a
          >
        </div>
      </div>
      <input
        type="file"
        id="fileInput"
        style="display: none"
        accept=".json"
        onchange="loadPath(this)"
      />
    </div>

    <h1>VEX Path Planner - Pro Editor v45</h1>

    <div class="top-controls">
      <div class="switch-container">
        <span style="font-size: 12px; color: #aaa">MOD:</span>
        <label class="switch">
          <input
            type="checkbox"
            id="modeToggle"
            onchange="toggleMode()"
            checked
          />
          <span class="slider"></span>
        </label>
        <span id="modeLabel">Nokta Ekleme</span>
      </div>

      <span style="border-left: 1px solid #555; height: 20px"></span>

      <div class="switch-container">
        <span style="font-size: 12px; color: #aaa">ORÄ°JÄ°N:</span>
        <label class="switch">
          <input type="checkbox" id="originToggle" onchange="toggleOrigin()" />
          <span class="slider orange"></span>
        </label>
        <span id="originLabel">Merkez</span>
      </div>

      <span style="border-left: 1px solid #555; height: 20px"></span>

      <div class="switch-container">
        <span style="font-size: 12px; color: #aaa">GÃ–RSEL:</span>
        <label class="switch">
          <input type="checkbox" id="curveToggle" onchange="updateSettings()" />
          <span class="slider green"></span>
        </label>
        <span id="curveLabel">DÃ¼z Ã‡izgi</span>
      </div>

      <label for="pointCountInput">Nokta SayÄ±sÄ±:</label>
      <input
        type="number"
        id="pointCountInput"
        value="20"
        min="2"
        max="100"
        onchange="updateSettings()"
      />

      <label for="globalSpeedInput">Genel HÄ±z:</label>
      <input
        type="text"
        id="globalSpeedInput"
        value="127"
        style="width: 60px"
        onchange="updateGlobalSpeed()"
      />
    </div>

    <div class="main-layout">
      <div class="left-sidebar">
        <h3>Robot AyarlarÄ±</h3>

        <div class="setting-group-inline">
          <label>GeniÅŸlik (inÃ§):</label>
          <input
            type="number"
            id="simWidthInput"
            value="15"
            onchange="updateDimensions()"
          />
        </div>

        <div class="setting-group-inline">
          <label>Uzunluk (inÃ§):</label>
          <input
            type="number"
            id="simHeightInput"
            value="15"
            onchange="updateDimensions()"
          />
        </div>

        <div class="switch-container" style="justify-content: space-between">
          <span>GÃ¶rÃ¼nÃ¼rlÃ¼k:</span>
          <label class="switch">
            <input type="checkbox" id="simToggle" onchange="drawScreen()" />
            <span class="slider pink"></span>
          </label>
        </div>

        <h3>Mekanizma YÃ¶nleri</h3>

        <div class="setting-group-inline">
          <label>Intake:</label>
          <button
            class="toggle-action-btn mech-btn"
            id="btn-intake"
            onclick="toggleMech('intake', this)"
          >
            Ã–nde
          </button>
        </div>

        <div class="setting-group-inline">
          <label>Long Shooter:</label>
          <button
            class="toggle-action-btn mech-btn"
            id="btn-long"
            onclick="toggleMech('long', this)"
          >
            Ã–nde
          </button>
        </div>

        <div class="setting-group-inline">
          <label>Mid Shooter:</label>
          <button
            class="toggle-action-btn mech-btn"
            id="btn-mid"
            onclick="toggleMech('mid', this)"
          >
            Ã–nde
          </button>
        </div>

        <div class="setting-group-inline">
          <label>Low Shooter:</label>
          <button
            class="toggle-action-btn mech-btn"
            id="btn-low"
            onclick="toggleMech('low', this)"
          >
            Ã–nde
          </button>
        </div>

        <button class="play-btn" id="playBtn" onclick="toggleAnimation()">
          â–¶ Oynat
        </button>
      </div>

      <div class="canvas-wrapper">
        <canvas id="fieldCanvas" width="600" height="600"></canvas>
      </div>

      <div class="settings-panel">
        <h3>Nokta DÃ¼zenleyici</h3>

        <div
          id="noSelectionMsg"
          style="
            text-align: center;
            color: #666;
            margin-top: 20px;
            font-size: 0.9rem;
          "
        >
          Bir nokta seÃ§ili deÄŸil.<br /><br />BaÅŸlangÄ±Ã§ noktasÄ± yeÅŸil renklidir.
          SÃ¼rÃ¼kleyerek taÅŸÄ±yabilirsiniz.
        </div>

        <div id="selectionControls" style="display: none">
          <div class="setting-group setting-group-separator">
            <label
              >SeÃ§ili Nokta:
              <span
                id="selectedIndexDisplay"
                style="font-weight: bold; color: #fff; float: right"
                >#0</span
              ></label
            >
          </div>

          <div class="setting-group setting-group-separator">
            <label>Nokta AdÄ±:</label>
            <input
              type="text"
              id="pointNameInput"
              class="full-width-input"
              placeholder="Ã–rn: Halka Al"
              oninput="manualNameChange(this.value)"
            />
          </div>

          <div id="movementSettings">
            <div class="setting-group-inline">
              <label>Nokta HÄ±zÄ±:</label>
              <input
                type="text"
                id="pointSpeedInput"
                oninput="manualSpeedChange(this.value)"
              />
            </div>

            <div class="setting-group-inline">
              <label>Hareket YÃ¶nÃ¼:</label>
              <button
                class="toggle-action-btn"
                id="pointDirBtn"
                onclick="togglePointDir(this)"
              >
                Ä°leri
              </button>
            </div>
          </div>

          <div class="setting-group">
            <label>Konum (X=Dikey, Y=Yatay):</label>
            <div class="coord-inputs">
              <span>X:</span>
              <input
                type="number"
                id="coordXInput"
                step="0.5"
                onchange="manualCoordChange()"
              />
            </div>
            <div class="coord-inputs" style="margin-top: 5px">
              <span>Y:</span>
              <input
                type="number"
                id="coordYInput"
                step="0.5"
                onchange="manualCoordChange()"
              />
            </div>
          </div>

          <div class="setting-group setting-group-separator">
            <label>AÃ§Ä± (Derece):</label>
            <div class="angle-control">
              <input
                type="number"
                id="angleInput"
                value="0"
                min="-180"
                max="180"
                oninput="manualAngleChange(this.value)"
              />
              <button
                onclick="resetAngle()"
                style="padding: 2px; font-size: 10px; width: auto; flex: 0"
              >
                Oto
              </button>
            </div>

            <div class="knob-wrapper">
              <div class="knob-container" id="knobContainer">
                <div class="knob-track"></div>
                <div class="handle-rotator" id="handleRotator">
                  <div class="knob-handle" id="knobHandle"></div>
                </div>
              </div>
            </div>
            <div class="angle-buttons">
              <button onclick="rotateAngle(-90)">â†º -90Â°</button>
              <button onclick="rotateAngle(90)">â†» +90Â°</button>
            </div>
            <div
              style="
                font-size: 9px;
                color: #777;
                margin-top: 4px;
                text-align: center;
              "
            >
              SaÄŸ(Y+):0, AÅŸaÄŸÄ±(X+):90, YukarÄ±:-90
            </div>
          </div>

          <button
            class="delete-pt"
            id="deleteBtn"
            onclick="deleteSelectedPoint()"
          >
            NoktayÄ± Sil
          </button>
        </div>
      </div>

      <div class="output-panel">
        <h3 style="margin: 0; color: #fff; font-size: 0.9rem">HÄ±zlÄ± AraÃ§lar</h3>
        <div class="tools-menu">
          <button class="tool-btn" onclick="mirrorPath('X')">
            â†” Yatay Aynala
          </button>
          <button class="tool-btn" onclick="mirrorPath('Y')">
            â†• Dikey Aynala
          </button>
        </div>

        <h3 style="margin-top: 5px; color: #fff; font-size: 0.9rem">
          Kod Ã‡Ä±ktÄ±sÄ±
        </h3>
        <textarea id="outputBox" readonly>
// LÃ¼tfen haritaya tÄ±klayarak baÅŸlangÄ±Ã§ noktasÄ±nÄ± (robotu) yerleÅŸtirin.</textarea
        >

        <div class="btn-group">
          <button onclick="copyToClipboard()">Kopyala</button>
          <button class="undo" onclick="undoLastPoint()" id="undoBtn">
            Geri Al
          </button>
          <button class="clear" onclick="clearCanvas()">TÃ¼mÃ¼ Sil</button>
        </div>
      </div>
    </div>

    <script>
      // --- DEÄžÄ°ÅžKENLER ---
      const canvas = document.getElementById("fieldCanvas");
      const ctx = canvas.getContext("2d");
      const outputBox = document.getElementById("outputBox");
      const pointCountInput = document.getElementById("pointCountInput");
      const globalSpeedInput = document.getElementById("globalSpeedInput");
      const modeLabel = document.getElementById("modeLabel");
      const curveToggle = document.getElementById("curveToggle");
      const curveLabel = document.getElementById("curveLabel");

      const noSelectionMsg = document.getElementById("noSelectionMsg");
      const selectionControls = document.getElementById("selectionControls");
      const selectedIndexDisplay = document.getElementById(
        "selectedIndexDisplay"
      );
      const coordXInput = document.getElementById("coordXInput");
      const coordYInput = document.getElementById("coordYInput");
      const angleInput = document.getElementById("angleInput");

      // Knob DeÄŸiÅŸkenleri
      const knobContainer = document.getElementById("knobContainer");
      const handleRotator = document.getElementById("handleRotator");
      const knobHandle = document.getElementById("knobHandle");
      let isKnobDragging = false;

      // Robot SimÃ¼lasyon DeÄŸiÅŸkenleri
      const simWidthInput = document.getElementById("simWidthInput");
      const simHeightInput = document.getElementById("simHeightInput");
      const simToggle = document.getElementById("simToggle");
      const playBtn = document.getElementById("playBtn");

      let currentSimIndex = 0;
      let isSimDragging = false;
      let isPlaying = false;
      let animationFrameId = null;

      // Orijin AyarÄ±
      const originToggle = document.getElementById("originToggle");
      const originLabel = document.getElementById("originLabel");
      let isRelativeOrigin = false;

      // Undo/Redo YÄ±ÄŸÄ±nlarÄ±
      let undoStack = [];
      let redoStack = [];
      const MAX_STACK_SIZE = 50;

      const pointNameInput = document.getElementById("pointNameInput");
      const pointSpeedInput = document.getElementById("pointSpeedInput");
      // pointDirInput kaldÄ±rÄ±ldÄ±, yerine buton geldi
      const pointDirBtn = document.getElementById("pointDirBtn");
      const movementSettings = document.getElementById("movementSettings");
      const deleteBtn = document.getElementById("deleteBtn");

      // MEKANÄ°ZMA DURUMU
      let mechanismState = {
        intake: "front",
        long: "front",
        mid: "front",
        low: "front",
      };

      const bgImage = new Image();
      bgImage.src = "field.png";

      const FIELD_SIZE_INCHES = 144;
      const CANVAS_SIZE = 600;
      const PIXELS_PER_INCH = CANVAS_SIZE / FIELD_SIZE_INCHES;
      const OFFSET_X = 0;
      const OFFSET_Y = 0;

      // GÃœNCEL DÄ°NAMÄ°K ALANLAR (Variable)
      let currentSnapZones = [];

      let rawPoints = [];
      let processedPoints = [];

      let isPointMode = true;
      let isDrawing = false;
      let isDragging = false;
      let selectedPointIndex = -1;

      bgImage.onload = function () {
        updateDimensions(); // Ä°lk aÃ§Ä±lÄ±ÅŸta zonlarÄ± hesapla
        drawScreen();
      };

      // --- BOYUT DEÄžÄ°ÅžÄ°NCE TETÄ°KLENEN FONKSÄ°YON ---
      function updateDimensions() {
        // Snap Zone'larÄ± yeniden hesapla
        currentSnapZones = getDynamicSnapZones();
        // EkranÄ± yenile (Robot boyutu deÄŸiÅŸtiÄŸi iÃ§in)
        drawScreen();
      }

      // --- DÄ°NAMÄ°K HÄ°ZALAMA ALANLARI OLUÅžTURUCU ---
      function getDynamicSnapZones() {
        let w = parseFloat(simWidthInput.value) || 15;
        let h = parseFloat(simHeightInput.value) || 15;

        // Robot 15'ten bÃ¼yÃ¼kse merkezden uzaklaÅŸ (geriye git), kÃ¼Ã§Ã¼kse yaklaÅŸ.
        // DÃ¼z kenarlar iÃ§in sadece H Ã¶nemli (ileri/geri).
        let offset = (h - 15) / 2;

        // Ã‡aprazlar iÃ§in hem X hem Y artmalÄ±/azalmalÄ±.
        let diagOffset = offset;

        return [
          // --- INTAKE (64'lÃ¼ler - DÃ¼z Kenar) ---
          // 48, 64 (0 Derece / SaÄŸ). Geriye gitmek Y'yi azaltmaktÄ±r.
          { x: 48, y: 64 - offset, w: 10, h: 10, angle: 0, type: "intake" },
          // -48, 64 (0 Derece / SaÄŸ).
          { x: -48, y: 64 - offset, w: 10, h: 10, angle: 0, type: "intake" },
          // -48, -64 (180 Derece / Sol). Geriye gitmek Y'yi arttÄ±rmaktÄ±r.
          { x: -48, y: -64 + offset, w: 10, h: 10, angle: 180, type: "intake" },
          // 48, -64 (180 Derece / Sol).
          { x: 48, y: -64 + offset, w: 10, h: 10, angle: 180, type: "intake" },

          // --- LONG SHOOTER (30'lular - DÃ¼z Kenar) ---
          // 48, 30 (180 Derece / Sol). Y arttÄ±r.
          { x: 48, y: 30 + offset, w: 10, h: 10, angle: 180, type: "long" },
          // -48, 30 (180 Derece / Sol).
          { x: -48, y: 30 + offset, w: 10, h: 10, angle: 180, type: "long" },
          // 48, -30 (0 Derece / SaÄŸ). Y azalt.
          { x: 48, y: -30 - offset, w: 10, h: 10, angle: 0, type: "long" },
          // -48, -30 (0 Derece / SaÄŸ).
          { x: -48, y: -30 - offset, w: 10, h: 10, angle: 0, type: "long" },

          // --- MID SHOOTER (Ã‡aprazlar - Merkezden DÄ±ÅŸarÄ±) ---
          // 14, 14 (Angle -135). DÄ±ÅŸarÄ± gitmek iÃ§in 14'ten bÃ¼yÃ¼k olmalÄ± (14 + off)
          {
            x: 14 + diagOffset,
            y: 14 + diagOffset,
            w: 10,
            h: 10,
            angle: -135,
            type: "mid",
          },
          // -14, -14 (Angle 45). DÄ±ÅŸarÄ± gitmek iÃ§in -14'ten kÃ¼Ã§Ã¼k olmalÄ± (-14 - off)
          {
            x: -14 - diagOffset,
            y: -14 - diagOffset,
            w: 10,
            h: 10,
            angle: 45,
            type: "mid",
          },

          // --- LOW SHOOTER (Ã‡aprazlar - Merkezden DÄ±ÅŸarÄ±) ---
          // -14, 14 (Angle 135). X azalmalÄ± (-), Y artmalÄ± (+)
          {
            x: -14 - diagOffset,
            y: 14 + diagOffset,
            w: 10,
            h: 10,
            angle: 135,
            type: "low",
          },
          // 14, -14 (Angle -45). X artmalÄ± (+), Y azalmalÄ± (-)
          {
            x: 14 + diagOffset,
            y: -14 - diagOffset,
            w: 10,
            h: 10,
            angle: -45,
            type: "low",
          },
        ];
      }

      // --- MEKANÄ°ZMA AYARLAMA (TEK BUTON TOGGLE) ---
      function toggleMech(mechType, btnElement) {
        saveState();

        let currentSide = mechanismState[mechType];
        let newSide = currentSide === "front" ? "back" : "front";

        mechanismState[mechType] = newSide;

        updateMechButtonVisual(btnElement, newSide);
        updateSnapZones(); // Mevcut noktalarÄ± gÃ¼ncelle
      }

      function updateMechButtonVisual(btn, side) {
        if (side === "front") {
          btn.innerText = "Ã–nde";
          // btn.classList.remove('secondary-state'); // Pembe kalacak
        } else {
          btn.innerText = "Arkada";
          // btn.classList.add('secondary-state'); // Pembe kalacak
        }
      }

      function updateUIForMechanisms() {
        // YÃ¼kleme sÄ±rasÄ±nda tÃ¼m butonlarÄ± gÃ¼ncelle
        updateMechButtonVisual(
          document.getElementById("btn-intake"),
          mechanismState.intake
        );
        updateMechButtonVisual(
          document.getElementById("btn-long"),
          mechanismState.long
        );
        updateMechButtonVisual(
          document.getElementById("btn-mid"),
          mechanismState.mid
        );
        updateMechButtonVisual(
          document.getElementById("btn-low"),
          mechanismState.low
        );
      }

      // --- NOKTA YÃ–NÃœ DEÄžÄ°ÅžTÄ°RME (TEK BUTON) ---
      function togglePointDir(btnElement) {
        if (selectedPointIndex !== -1 && selectedPointIndex !== 0) {
          saveState();
          let list = isPointMode ? rawPoints : processedPoints;
          let currentDir = list[selectedPointIndex].dir || "fwd";
          let newDir = currentDir === "fwd" ? "rev" : "fwd";

          list[selectedPointIndex].dir = newDir;

          updatePointDirButtonVisual(btnElement, newDir);
          generateFormattedOutput(list);
        }
      }

      function updatePointDirButtonVisual(btn, dir) {
        if (dir === "fwd") {
          btn.innerText = "Ä°leri";
          // btn.classList.remove('secondary-state'); // Turuncu kalacak
        } else {
          btn.innerText = "Geri";
          // btn.classList.add('secondary-state'); // Turuncu kalacak
        }
      }

      // --- MEKANÄ°ZMA GÃœNCELLEME ---
      function updateSnapZones() {
        let changed = false;
        rawPoints.forEach((p) => {
          let snapped = getSnappedPosition(p.x, p.y);
          if (snapped.snapped && snapped.hasAngle) {
            if (p.customHeading !== snapped.angle) {
              p.customHeading = snapped.angle;
              changed = true;
            }
          }
        });

        if (changed) {
          drawScreen();
          updateSelectionUI();
          generateFormattedOutput(isPointMode ? rawPoints : processedPoints);
        }
      }

      // --- SNAP / HÄ°ZALAMA FONKSÄ°YONLARI ---
      function inchToPixel(inchX, inchY) {
        let px = inchY * PIXELS_PER_INCH + CANVAS_SIZE / 2; // Yatay
        let py = inchX * PIXELS_PER_INCH + CANVAS_SIZE / 2; // Dikey
        return { x: px, y: py };
      }

      function drawSnapZones() {
        // GÃ¶rÃ¼nmez kalsÄ±n
      }

      function getAdjustedAngle(baseAngle, type) {
        let isBack = false;
        if (type === "intake" && mechanismState.intake === "back")
          isBack = true;
        if (type === "long" && mechanismState.long === "back") isBack = true;
        if (type === "mid" && mechanismState.mid === "back") isBack = true;
        if (type === "low" && mechanismState.low === "back") isBack = true;

        if (isBack) {
          return (baseAngle + 180) % 360;
        }
        return baseAngle;
      }

      function normalizeAngle(angle) {
        while (angle > 180) angle -= 360;
        while (angle <= -180) angle += 360;
        return angle;
      }

      // DÄ°NAMÄ°K LÄ°STE KULLANIYORUZ ARTIK (currentSnapZones)
      function getSnappedPosition(mx, my) {
        let result = {
          x: mx,
          y: my,
          snapped: false,
          angle: null,
          hasAngle: false,
        };

        // EÄŸer liste boÅŸsa oluÅŸtur (gÃ¼venlik iÃ§in)
        if (currentSnapZones.length === 0)
          currentSnapZones = getDynamicSnapZones();

        for (let zone of currentSnapZones) {
          let center = inchToPixel(zone.x, zone.y);
          let wPx = zone.w * PIXELS_PER_INCH;
          let hPx = zone.h * PIXELS_PER_INCH;

          let left = center.x - wPx / 2;
          let right = center.x + wPx / 2;
          let top = center.y - hPx / 2;
          let bottom = center.y + hPx / 2;

          if (mx >= left && mx <= right && my >= top && my <= bottom) {
            result.x = center.x;
            result.y = center.y;
            result.snapped = true;

            if (zone.angle !== undefined) {
              let finalAngle = getAdjustedAngle(zone.angle, zone.type);
              result.angle = normalizeAngle(finalAngle);
              result.hasAngle = true;
            }
            break;
          }
        }
        return result;
      }

      // --- UNDO / REDO SÄ°STEMÄ° ---
      function saveState() {
        const state = {
          rawPoints: JSON.parse(JSON.stringify(rawPoints)),
          processedPoints: JSON.parse(JSON.stringify(processedPoints)),
          selectedPointIndex: selectedPointIndex,
          isPointMode: isPointMode,
          mechanismState: JSON.parse(JSON.stringify(mechanismState)),
        };
        undoStack.push(state);
        if (undoStack.length > MAX_STACK_SIZE) undoStack.shift();
        redoStack = [];
      }

      function undo() {
        if (undoStack.length === 0) return;

        const currentState = {
          rawPoints: JSON.parse(JSON.stringify(rawPoints)),
          processedPoints: JSON.parse(JSON.stringify(processedPoints)),
          selectedPointIndex: selectedPointIndex,
          isPointMode: isPointMode,
          mechanismState: JSON.parse(JSON.stringify(mechanismState)),
        };
        redoStack.push(currentState);

        const prevState = undoStack.pop();
        restoreState(prevState);
      }

      function redo() {
        if (redoStack.length === 0) return;

        const currentState = {
          rawPoints: JSON.parse(JSON.stringify(rawPoints)),
          processedPoints: JSON.parse(JSON.stringify(processedPoints)),
          selectedPointIndex: selectedPointIndex,
          isPointMode: isPointMode,
          mechanismState: JSON.parse(JSON.stringify(mechanismState)),
        };
        undoStack.push(currentState);

        const nextState = redoStack.pop();
        restoreState(nextState);
      }

      function restoreState(state) {
        rawPoints = state.rawPoints;
        processedPoints = state.processedPoints;
        selectedPointIndex = state.selectedPointIndex;
        isPointMode = state.isPointMode;

        if (state.mechanismState) {
          mechanismState = state.mechanismState;
          updateUIForMechanisms();
        }

        document.getElementById("modeToggle").checked = isPointMode;
        modeLabel.innerText = isPointMode ? "Nokta Ekleme" : "Serbest Ã‡izim";

        updateSelectionUI();
        drawScreen();
        generateFormattedOutput(isPointMode ? rawPoints : processedPoints);
      }

      function undoLastPoint() {
        undo();
      }

      // --- KLAVYE KISAYOLLARI ---
      document.addEventListener("keydown", (e) => {
        if (e.key === "Delete") {
          if (selectedPointIndex !== -1) deleteSelectedPoint();
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z") {
          e.preventDefault();
          undo();
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "y") {
          e.preventDefault();
          redo();
        }
      });

      // --- ORÄ°JÄ°N FONKSÄ°YONU ---
      function toggleOrigin() {
        isRelativeOrigin = originToggle.checked;
        if (isRelativeOrigin) {
          originLabel.innerText = "BaÅŸlangÄ±Ã§";
        } else {
          originLabel.innerText = "Merkez";
        }
        drawScreen();
        updateSelectionUI();
        generateFormattedOutput(isPointMode ? rawPoints : processedPoints);
      }

      // --- SÃœREKLÄ° GÃœNCEL GENEL HIZ FONKSÄ°YONU ---
      function updateGlobalSpeed() {
        saveState();
        let val = globalSpeedInput.value;
        for (let i = 0; i < rawPoints.length; i++) {
          rawPoints[i].speed = val;
        }
        if (selectedPointIndex !== -1) {
          pointSpeedInput.value = val;
        }
        processPath(true);
      }

      // --- ANIMASYON MANTIÄžI ---
      function toggleAnimation() {
        if (!simToggle.checked) {
          alert("LÃ¼tfen Ã¶nce Robot GÃ¶rÃ¼nÃ¼mÃ¼nÃ¼ (GÃ¶ster) aÃ§Ä±n.");
          return;
        }
        if (processedPoints.length < 2) return;

        isPlaying = !isPlaying;
        if (isPlaying) {
          playBtn.innerHTML = "â¹ Durdur";
          playBtn.classList.add("playing");
          let path = getVisualPathPoints();
          if (currentSimIndex >= path.length - 1) {
            currentSimIndex = 0;
          }
          animate();
        } else {
          playBtn.innerHTML = "â–¶ Oynat";
          playBtn.classList.remove("playing");
          cancelAnimationFrame(animationFrameId);
        }
      }

      function animate() {
        if (!isPlaying) return;

        let path = getVisualPathPoints();
        if (currentSimIndex < path.length - 1) {
          let currentSpeed = 127;
          if (path[Math.floor(currentSimIndex)].speed)
            currentSpeed = parseInt(path[Math.floor(currentSimIndex)].speed);

          // HÄ±z
          let step = currentSpeed / 40;

          currentSimIndex += step;
          if (currentSimIndex >= path.length - 1) {
            currentSimIndex = path.length - 1;
            isPlaying = false;
            playBtn.innerHTML = "â–¶ Oynat";
            playBtn.classList.remove("playing");
          }
          drawScreen();
          animationFrameId = requestAnimationFrame(animate);
        }
      }

      // --- KNOB EVENTLERÄ° ---
      knobHandle.addEventListener("mousedown", (e) => {
        saveState();
        isKnobDragging = true;
        e.preventDefault();
        e.stopPropagation();
      });

      document.addEventListener("mouseup", () => {
        isKnobDragging = false;
        isSimDragging = false;
      });

      document.addEventListener("mousemove", (e) => {
        if (isKnobDragging) {
          const rect = knobContainer.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          const deltaX = e.clientX - centerX;
          const deltaY = e.clientY - centerY;
          let radians = Math.atan2(deltaY, deltaX);
          let degrees = radians * (180 / Math.PI);
          degrees = Math.round(degrees);
          handleRotator.style.transform = `rotate(${degrees}deg)`;
          manualAngleChange(degrees, false);
        }
      });
      // -----------------------

      function savePath() {
        let listToSave = isPointMode || isDrawing ? rawPoints : processedPoints;
        const data = {
          version: "v45",
          points: listToSave,
          settings: {
            isPointMode: isPointMode,
            curveEnabled: curveToggle.checked,
            pointCount: pointCountInput.value,
            globalSpeed: globalSpeedInput.value,
            robotSim: {
              width: simWidthInput.value,
              height: simHeightInput.value,
              show: simToggle.checked,
            },
            relativeOrigin: isRelativeOrigin,
            mechanisms: mechanismState,
          },
        };

        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "vex_path.json";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      function loadPath(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            saveState();

            const data = JSON.parse(e.target.result);
            if (data.points) {
              rawPoints = data.points;
              processedPoints = rawPoints.slice();
            }
            if (data.settings) {
              document.getElementById("modeToggle").checked =
                data.settings.isPointMode;
              toggleMode();
              curveToggle.checked = data.settings.curveEnabled;
              updateSettings();
              pointCountInput.value = data.settings.pointCount || 20;
              globalSpeedInput.value = data.settings.globalSpeed || "127";

              if (data.settings.robotSim) {
                simWidthInput.value = data.settings.robotSim.width;
                simHeightInput.value = data.settings.robotSim.height;
                simToggle.checked = data.settings.robotSim.show;
              }
              if (data.settings.relativeOrigin !== undefined) {
                originToggle.checked = data.settings.relativeOrigin;
                toggleOrigin();
              }
              // Mekanizma ayarlarÄ±nÄ± yÃ¼kle
              if (data.settings.mechanisms) {
                mechanismState = data.settings.mechanisms;
                updateUIForMechanisms();
              }
            }
            // Boyutlar deÄŸiÅŸmiÅŸ olabilir, snap zone'larÄ± gÃ¼ncelle
            updateDimensions();

            selectedPointIndex = -1;
            updateSelectionUI();
            processPath(true);
            alert("Proje baÅŸarÄ±yla yÃ¼klendi!");
          } catch (err) {
            alert("Dosya okuma hatasÄ±!");
            console.error(err);
          }
        };
        reader.readAsText(file);
        input.value = "";
      }

      // --- MOD YÃ–NETÄ°MÄ° ---
      function toggleMode() {
        const toggle = document.getElementById("modeToggle");
        isPointMode = toggle.checked;

        if (isPointMode) {
          modeLabel.innerText = "Nokta Ekleme";
          canvas.style.cursor = "default";
          document.getElementById("undoBtn").style.display = "block";
          pointCountInput.disabled = true;
        } else {
          modeLabel.innerText = "Serbest Ã‡izim";
          canvas.style.cursor = "crosshair";
          selectedPointIndex = -1;
          updateSelectionUI();
          document.getElementById("undoBtn").style.display = "none";
          pointCountInput.disabled = false;
        }
        clearCanvasKeepPoints();
      }

      function clearCanvasKeepPoints() {
        drawScreen();
      }

      function updateSettings() {
        if (curveToggle.checked) {
          curveLabel.innerText = "AkÄ±llÄ± EÄŸri";
          curveLabel.style.color = "#28a745";
        } else {
          curveLabel.innerText = "DÃ¼z Ã‡izgi";
          curveLabel.style.color = "#aaa";
        }
        processPath();
      }

      // --- MOUSE EVENTLERÄ° (CANVAS - GÃœNCELLENMÄ°Åž HIT TEST + SNAP) ---
      canvas.addEventListener("mousedown", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        // 1. SÄ°MÃœLASYON KUTUSUNA TIKLAMA KONTROLÃœ
        if (simToggle.checked && processedPoints.length > 1) {
          let visualPath = getVisualPathPoints();
          let idx = Math.floor(currentSimIndex);
          if (idx < visualPath.length) {
            let p = visualPath[idx];

            let angle = 0;
            if (idx < visualPath.length - 1) {
              angle = calculateRawHeading(p, visualPath[idx + 1]);
            } else if (idx > 0) {
              angle = calculateRawHeading(visualPath[idx - 1], p);
            }
            if (p.dir === "rev") angle += 180;

            let w = parseFloat(simWidthInput.value) * PIXELS_PER_INCH;
            let h = parseFloat(simHeightInput.value) * PIXELS_PER_INCH;

            let dx = mx - p.x;
            let dy = my - p.y;
            let rad = -angle * (Math.PI / 180);
            let localX = dx * Math.cos(rad) - dy * Math.sin(rad);
            let localY = dx * Math.sin(rad) + dy * Math.cos(rad);

            if (Math.abs(localX) <= w / 2 && Math.abs(localY) <= h / 2) {
              isSimDragging = true;
              if (isPlaying) toggleAnimation();
              return;
            }
          }
        }

        // 2. NOKTA SEÃ‡ME
        let targetList = isPointMode || isDrawing ? rawPoints : processedPoints;
        let clickedIndex = -1;
        for (let i = targetList.length - 1; i >= 0; i--) {
          const dist = Math.hypot(targetList[i].x - mx, targetList[i].y - my);
          if (dist < 15) {
            clickedIndex = i;
            break;
          }
        }

        if (clickedIndex !== -1) {
          selectedPointIndex = clickedIndex;
          isDragging = true;
          saveState();
          updateSelectionUI();
          drawScreen();
          return;
        }

        if (selectedPointIndex !== -1) {
          selectedPointIndex = -1;
          updateSelectionUI();
          drawScreen();
          return;
        }

        // 3. YENÄ° NOKTA EKLEME (SNAP + OTO AÃ‡I)
        let snapped = getSnappedPosition(mx, my);

        if (isPointMode) {
          saveState();
          addRawPoint(snapped.x, snapped.y);

          if (snapped.hasAngle) {
            rawPoints[rawPoints.length - 1].customHeading = snapped.angle;
          }

          processPath();
          selectedPointIndex = rawPoints.length - 1;
          isDragging = true;
          updateSelectionUI();
        } else {
          saveState();
          isDrawing = true;
          rawPoints = [];
          processedPoints = [];
          selectedPointIndex = -1;
          addRawPoint(snapped.x, snapped.y);

          if (snapped.hasAngle) {
            rawPoints[rawPoints.length - 1].customHeading = snapped.angle;
          }

          drawScreen();
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        if (isSimDragging && simToggle.checked) {
          let visualPath = getVisualPathPoints();
          let minDist = Infinity;
          let closestIndex = 0;

          for (let i = 0; i < visualPath.length; i++) {
            let d = Math.hypot(visualPath[i].x - mx, visualPath[i].y - my);
            if (d < minDist) {
              minDist = d;
              closestIndex = i;
            }
          }
          currentSimIndex = closestIndex;
          drawScreen();
          return;
        }

        if (isDragging && selectedPointIndex !== -1) {
          let targetList =
            isPointMode || isDrawing ? rawPoints : processedPoints;
          if (targetList[selectedPointIndex]) {
            let snapped = getSnappedPosition(mx, my);

            targetList[selectedPointIndex].x = snapped.x;
            targetList[selectedPointIndex].y = snapped.y;

            if (snapped.hasAngle) {
              targetList[selectedPointIndex].customHeading = snapped.angle;
            }

            const coords = getCoordinatesInches(targetList[selectedPointIndex]);
            coordXInput.value = coords.x.toFixed(2);
            coordYInput.value = coords.y.toFixed(2);

            drawScreen();
            if (!isDrawing) processPath(true);

            if (snapped.hasAngle) {
              updateSelectionUI();
            }
          }
          return;
        }

        if (!isPointMode && isDrawing) {
          let snapped = getSnappedPosition(mx, my);
          addRawPoint(snapped.x, snapped.y);
          drawScreen();
        }
      });

      canvas.addEventListener("mouseup", () => {
        if (isDragging) {
          isDragging = false;
          if (!isDrawing) processPath(true);
        }

        if (!isPointMode && isDrawing) {
          isDrawing = false;
          processPath();
        }
      });

      // --- NOKTA Ä°ÅžLEMLERÄ° ---
      function addRawPoint(x, y) {
        let defaultSpeed = globalSpeedInput.value || "127";
        rawPoints.push({
          x,
          y,
          customHeading: null,
          name: "",
          speed: defaultSpeed,
          dir: "fwd",
        });
      }

      function deleteSelectedPoint() {
        if (selectedPointIndex !== -1) {
          saveState();
          let list = isPointMode ? rawPoints : processedPoints;
          list.splice(selectedPointIndex, 1);
          if (list.length === 0) {
            clearCanvas();
            return;
          }
          if (selectedPointIndex >= list.length) {
            selectedPointIndex = list.length - 1;
          }
          updateSelectionUI();
          processPath(true);
        }
      }

      function undoLastPoint() {
        let targetList = isPointMode ? rawPoints : processedPoints;
        if (targetList.length > 1) {
          targetList.pop();
          selectedPointIndex = -1;
          updateSelectionUI();
          processPath(true);
        }
      }

      function clearCanvas() {
        saveState();
        rawPoints = [];
        processedPoints = [];
        selectedPointIndex = -1;
        updateSelectionUI();
        drawScreen();
        outputBox.value =
          "// LÃ¼tfen haritaya tÄ±klayarak baÅŸlangÄ±Ã§ noktasÄ±nÄ± (robotu) yerleÅŸtirin.";
      }

      function mirrorPath(axis) {
        if (rawPoints.length === 0) return;
        saveState();

        let targetList = isPointMode || isDrawing ? rawPoints : processedPoints;
        const cx = CANVAS_SIZE / 2;
        const cy = CANVAS_SIZE / 2;

        targetList.forEach((p) => {
          if (axis === "X") {
            let distFromCenter = p.x - cx;
            p.x = cx - distFromCenter;
            if (p.customHeading !== null) {
              let a = p.customHeading;
              p.customHeading = 180 - a;
              while (p.customHeading > 180) p.customHeading -= 360;
              while (p.customHeading < -180) p.customHeading += 360;
            }
          } else if (axis === "Y") {
            let distFromCenter = p.y - cy;
            p.y = cy - distFromCenter;
            if (p.customHeading !== null) {
              p.customHeading = -p.customHeading;
            }
          }
        });

        drawScreen();
        generateFormattedOutput(targetList);
        if (selectedPointIndex !== -1) updateSelectionUI();
      }

      // --- UI GÃœNCELLEME ---
      function updateSelectionUI() {
        if (selectedPointIndex !== -1) {
          noSelectionMsg.style.display = "none";
          selectionControls.style.display = "block";

          let list = isPointMode || isDrawing ? rawPoints : processedPoints;
          if (!list[selectedPointIndex]) {
            selectedPointIndex = -1;
            return;
          }

          const p = list[selectedPointIndex];
          const coords = getCoordinatesInches(p);

          selectedIndexDisplay.innerText = "#" + (selectedPointIndex + 1);
          coordXInput.value = coords.x.toFixed(2);
          coordYInput.value = coords.y.toFixed(2);

          if (selectedPointIndex === 0) {
            pointNameInput.value = "BaÅŸlangÄ±Ã§ NoktasÄ±";
            pointNameInput.disabled = true;
            deleteBtn.disabled = false;
            deleteBtn.style.opacity = "1";
            movementSettings.style.display = "none";
          } else {
            pointNameInput.value = p.name || "";
            pointNameInput.disabled = false;
            deleteBtn.disabled = false;
            deleteBtn.style.opacity = "1";
            movementSettings.style.display = "block";
            pointSpeedInput.value = p.speed || globalSpeedInput.value;
            // Buton durumunu gÃ¼ncelle
            updatePointDirButtonVisual(pointDirBtn, p.dir || "fwd");
          }

          let displayAngle = 0;
          if (p.customHeading !== null) {
            displayAngle = p.customHeading;
            angleInput.value = displayAngle;
          } else {
            angleInput.value = "";
            angleInput.placeholder = "Oto";
            if (list.length > 1) {
              if (selectedPointIndex < list.length - 1) {
                displayAngle = calculateRawHeading(
                  p,
                  list[selectedPointIndex + 1]
                );
              } else {
                displayAngle = calculateRawHeading(
                  list[selectedPointIndex - 1],
                  p
                );
              }
            }
          }
          handleRotator.style.transform = `rotate(${displayAngle}deg)`;
        } else {
          noSelectionMsg.style.display = "block";
          selectionControls.style.display = "none";
        }
      }

      function manualNameChange(val) {
        if (selectedPointIndex !== -1 && selectedPointIndex !== 0) {
          let list = isPointMode ? rawPoints : processedPoints;
          list[selectedPointIndex].name = val;
          drawScreen();
          generateFormattedOutput(list);
        }
      }

      pointNameInput.addEventListener("focus", saveState);
      pointSpeedInput.addEventListener("focus", saveState);
      coordXInput.addEventListener("focus", saveState);
      coordYInput.addEventListener("focus", saveState);
      angleInput.addEventListener("focus", saveState);

      function manualSpeedChange(val) {
        if (selectedPointIndex !== -1 && selectedPointIndex !== 0) {
          let list = isPointMode ? rawPoints : processedPoints;
          list[selectedPointIndex].speed = val;
          generateFormattedOutput(list);
        }
      }

      function manualDirChange(val) {
        // Bu fonksiyon artÄ±k kullanÄ±lmÄ±yor, buton kullanÄ±lÄ±yor
      }

      function manualCoordChange() {
        if (selectedPointIndex === -1) return;
        let list = isPointMode ? rawPoints : processedPoints;

        let newXInches = parseFloat(coordXInput.value);
        let newYInches = parseFloat(coordYInput.value);
        if (isNaN(newXInches) || isNaN(newYInches)) return;

        let originX = CANVAS_SIZE / 2;
        let originY = CANVAS_SIZE / 2;
        if (isRelativeOrigin && rawPoints.length > 0) {
          originX = rawPoints[0].x;
          originY = rawPoints[0].y;
        }

        let pX = newYInches * PIXELS_PER_INCH + originX;
        let pY = newXInches * PIXELS_PER_INCH + originY;

        list[selectedPointIndex].x = pX;
        list[selectedPointIndex].y = pY;
        drawScreen();
        generateFormattedOutput(list);
      }

      function manualAngleChange(val, shouldSave = true) {
        if (selectedPointIndex !== -1) {
          let list = isPointMode ? rawPoints : processedPoints;
          let angleVal = parseFloat(val);
          list[selectedPointIndex].customHeading = angleVal;
          angleInput.value = val;

          if (!isNaN(angleVal)) {
            handleRotator.style.transform = `rotate(${angleVal}deg)`;
          }

          drawScreen();
          generateFormattedOutput(list);
        }
      }

      function rotateAngle(delta) {
        if (selectedPointIndex !== -1) {
          saveState();
          let list = isPointMode ? rawPoints : processedPoints;
          let current = list[selectedPointIndex].customHeading;
          if (current === null) current = 0;
          let newVal = current + delta;
          while (newVal > 180) newVal -= 360;
          while (newVal < -180) newVal += 360;
          list[selectedPointIndex].customHeading = newVal;
          updateSelectionUI();
          drawScreen();
          generateFormattedOutput(list);
        }
      }

      function resetAngle() {
        if (selectedPointIndex !== -1) {
          saveState();
          let list = isPointMode ? rawPoints : processedPoints;
          list[selectedPointIndex].customHeading = null;
          updateSelectionUI();
          drawScreen();
          generateFormattedOutput(list);
        }
      }

      function processPath(skipResample = false) {
        if (isPointMode) {
          processedPoints = rawPoints.slice();
        } else if (!isDrawing && rawPoints.length > 1) {
          if (!skipResample) {
            let desiredPoints = parseInt(pointCountInput.value) || 20;
            if (desiredPoints < 2) desiredPoints = 2;
            let defaultSpeed = globalSpeedInput.value;

            let totalLength = 0;
            let lengths = [0];
            for (let i = 0; i < rawPoints.length - 1; i++) {
              let dx = rawPoints[i + 1].x - rawPoints[i].x;
              let dy = rawPoints[i + 1].y - rawPoints[i].y;
              let dist = Math.hypot(dx, dy);
              totalLength += dist;
              lengths.push(totalLength);
            }

            let newPoints = [];
            let step = totalLength / (desiredPoints - 1);

            newPoints.push({
              x: rawPoints[0].x,
              y: rawPoints[0].y,
              customHeading: null,
              name: "BaÅŸlangÄ±Ã§ NoktasÄ±",
              speed: defaultSpeed,
              dir: "fwd",
            });

            for (let k = 1; k < desiredPoints - 1; k++) {
              let targetDist = k * step;
              let index = 0;
              while (
                index < lengths.length - 1 &&
                lengths[index + 1] < targetDist
              )
                index++;

              let segmentLen = lengths[index + 1] - lengths[index];
              let fraction = 0;
              if (segmentLen > 0)
                fraction = (targetDist - lengths[index]) / segmentLen;

              let p1 = rawPoints[index];
              let p2 = rawPoints[index + 1];

              let segSpeed = p2.speed || defaultSpeed;
              let segDir = p2.dir || "fwd";

              newPoints.push({
                x: p1.x + (p2.x - p1.x) * fraction,
                y: p1.y + (p2.y - p1.y) * fraction,
                customHeading: null,
                name: "",
                speed: segSpeed,
                dir: segDir,
              });
            }
            let lastP = rawPoints[rawPoints.length - 1];
            newPoints.push({
              x: lastP.x,
              y: lastP.y,
              customHeading: null,
              name: "",
              speed: defaultSpeed,
              dir: "fwd",
            });

            processedPoints = newPoints;
          }
        }
        drawScreen();
        generateFormattedOutput(processedPoints);
      }

      function getHermiteSplinePoints(points, segments) {
        if (points.length < 2) return points;
        let splinePoints = [];
        let tangents = [];
        for (let i = 0; i < points.length; i++) {
          let tX, tY;
          let magnitude = 0;
          let prev = points[i - 1] || points[i];
          let next = points[i + 1] || points[i];
          let dist = Math.hypot(next.x - prev.x, next.y - prev.y);
          if (i === 0 || i === points.length - 1) dist *= 2;
          magnitude = dist * 0.5;

          if (points[i].customHeading !== null) {
            let rad = (points[i].customHeading * Math.PI) / 180;
            tX = Math.cos(rad) * magnitude;
            tY = Math.sin(rad) * magnitude;
          } else {
            tX = (next.x - prev.x) * 0.5;
            tY = (next.y - prev.y) * 0.5;
          }
          tangents.push({ x: tX, y: tY });
        }

        for (let i = 0; i < points.length - 1; i++) {
          let p0 = points[i];
          let p1 = points[i + 1];
          let m0 = tangents[i];
          let m1 = tangents[i + 1];

          let segSpeed = p1.speed || "127";
          let segDir = p1.dir || "fwd";

          let distPixels = Math.hypot(p1.x - p0.x, p1.y - p0.y);
          let steps = Math.max(5, Math.floor(distPixels / 2));

          for (let k = 0; k <= steps; k++) {
            let t = k / steps;
            let s = t;
            let s2 = s * s;
            let s3 = s2 * s;
            let h1 = 2 * s3 - 3 * s2 + 1;
            let h2 = s3 - 2 * s2 + s;
            let h3 = -2 * s3 + 3 * s2;
            let h4 = s3 - s2;
            let x = h1 * p0.x + h2 * m0.x + h3 * p1.x + h4 * m1.x;
            let y = h1 * p0.y + h2 * m0.y + h3 * p1.y + h4 * m1.y;

            splinePoints.push({
              x: x,
              y: y,
              speed: segSpeed,
              dir: segDir,
            });
          }
        }
        return splinePoints;
      }

      function getVisualPathPoints() {
        if (processedPoints.length < 2) return [];

        if (curveToggle.checked) {
          return getHermiteSplinePoints(processedPoints, 0);
        } else {
          let pts = [];
          for (let i = 0; i < processedPoints.length - 1; i++) {
            let p1 = processedPoints[i];
            let p2 = processedPoints[i + 1];

            let segSpeed = p2.speed || "127";
            let segDir = p2.dir || "fwd";

            let distPixels = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            let steps = Math.max(2, Math.floor(distPixels / 2));

            for (let k = 0; k < steps; k++) {
              let t = k / steps;
              pts.push({
                x: p1.x + (p2.x - p1.x) * t,
                y: p1.y + (p2.y - p1.y) * t,
                speed: segSpeed,
                dir: segDir,
              });
            }
          }
          let last = processedPoints[processedPoints.length - 1];
          pts.push({
            x: last.x,
            y: last.y,
            speed: last.speed,
            dir: last.dir,
          });
          return pts;
        }
      }

      function drawScreen() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (bgImage.complete && bgImage.naturalHeight !== 0) {
          ctx.drawImage(bgImage, 0, 0, CANVAS_SIZE, CANVAS_SIZE);
        } else {
          ctx.fillStyle = "#333";
          ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
        }
        drawGrid();
        drawSnapZones(); // HÄ°ZALAMA ALANLARINI Ã‡Ä°Z
        drawOriginPoint();

        if (isDrawing && !isPointMode) {
          drawRawPath(rawPoints, false);
        } else {
          let visualPoints = processedPoints;
          let useCurveColor = false;

          if (curveToggle.checked && processedPoints.length > 1) {
            visualPoints = getHermiteSplinePoints(processedPoints, 20);
            useCurveColor = true;
          }

          if (processedPoints.length > 0) {
            if (processedPoints.length > 1)
              drawRawPath(visualPoints, useCurveColor);

            for (let i = 0; i < processedPoints.length; i++) {
              let visAngle = 0;
              if (processedPoints[i].customHeading !== null) {
                visAngle = processedPoints[i].customHeading;
              } else if (processedPoints.length > 1) {
                if (i < processedPoints.length - 1) {
                  visAngle = calculateRawHeading(
                    processedPoints[i],
                    processedPoints[i + 1]
                  );
                } else {
                  visAngle = calculateRawHeading(
                    processedPoints[i - 1],
                    processedPoints[i]
                  );
                }
              }
              drawFancyPoint(
                processedPoints[i],
                i === selectedPointIndex,
                visAngle,
                i === 0
              );
            }
          }

          if (simToggle.checked && processedPoints.length > 1) {
            drawRobotSimulation(visualPoints, useCurveColor);
          }
        }
      }

      function drawRobotSimulation(visualPoints, isCurved) {
        let simPath = getVisualPathPoints();
        if (simPath.length < 2) return;

        let idx = Math.floor(currentSimIndex);
        if (idx >= simPath.length) idx = simPath.length - 1;

        let p = simPath[idx];

        let angle = 0;
        if (idx < simPath.length - 1) {
          angle = calculateRawHeading(p, simPath[idx + 1]);
        } else if (idx > 0) {
          angle = calculateRawHeading(simPath[idx - 1], p);
        }

        if (p.dir === "rev") {
          angle += 180;
        }

        let w = parseFloat(simWidthInput.value) * PIXELS_PER_INCH;
        let h = parseFloat(simHeightInput.value) * PIXELS_PER_INCH;

        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate((angle * Math.PI) / 180);

        ctx.fillStyle = "rgba(214, 51, 132, 0.4)";
        ctx.strokeStyle = "#d63384";
        ctx.lineWidth = 2;

        ctx.fillRect(-h / 2, -w / 2, h, w);
        ctx.strokeRect(-h / 2, -w / 2, h, w);

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(w / 2, 0);
        ctx.strokeStyle = "white";
        ctx.lineWidth = 3;
        ctx.stroke();

        ctx.beginPath();
        ctx.lineTo(w / 2, 0);
        ctx.lineTo(w / 2 - 5, -5);
        ctx.lineTo(w / 2 - 5, 5);
        ctx.fillStyle = "white";
        ctx.fill();

        ctx.restore();
      }

      function drawFancyPoint(p, isSelected, headingDeg, isStart) {
        let radius = 8;
        ctx.beginPath();
        if (isStart)
          ctx.fillStyle = isSelected
            ? "rgba(40, 167, 69, 1.0)"
            : "rgba(40, 167, 69, 0.8)";
        else
          ctx.fillStyle = isSelected
            ? "rgba(255, 159, 67, 1.0)"
            : "rgba(255, 159, 67, 0.8)";

        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.fill();

        if (isSelected) {
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.stroke();
        } else {
          ctx.strokeStyle = "rgba(0,0,0,0.3)";
          ctx.lineWidth = 1;
          ctx.stroke();
        }

        let rad = (headingDeg * Math.PI) / 180;

        ctx.beginPath();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x + Math.cos(rad) * radius, p.y + Math.sin(rad) * radius);
        ctx.stroke();

        if (isSelected) {
          let displayName = p.name;
          if (isStart) displayName = "BaÅŸlangÄ±Ã§";

          if (displayName && displayName.length > 0) {
            ctx.fillStyle = "#fff";
            ctx.font = "bold 12px Arial";
            ctx.fillText(displayName, p.x + 12, p.y - 12);
          }
        }
      }

      function drawGrid() {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
        ctx.lineWidth = 1;
        const tileSize = 24 * PIXELS_PER_INCH;

        for (let i = 1; i < 6; i++) {
          ctx.beginPath();
          ctx.moveTo(i * tileSize, 0);
          ctx.lineTo(i * tileSize, CANVAS_SIZE);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, i * tileSize);
          ctx.lineTo(CANVAS_SIZE, i * tileSize);
          ctx.stroke();
        }

        ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(CANVAS_SIZE / 2, 0);
        ctx.lineTo(CANVAS_SIZE / 2, CANVAS_SIZE);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, CANVAS_SIZE / 2);
        ctx.lineTo(CANVAS_SIZE, CANVAS_SIZE / 2);
        ctx.stroke();
      }

      function drawOriginPoint() {
        const ox =
          isRelativeOrigin && rawPoints.length > 0
            ? rawPoints[0].x
            : CANVAS_SIZE / 2;
        const oy =
          isRelativeOrigin && rawPoints.length > 0
            ? rawPoints[0].y
            : CANVAS_SIZE / 2;

        ctx.fillStyle = "yellow";
        ctx.beginPath();
        ctx.arc(ox, oy, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,0.5)";
        ctx.font = "10px Arial";
        ctx.fillText("(0,0)", ox + 5, oy - 5);
      }

      function drawRawPath(pts, isCurved) {
        if (pts.length < 2) return;
        ctx.beginPath();
        ctx.strokeStyle = isCurved ? "#28a745" : "cyan";
        ctx.lineWidth = 2;
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
        ctx.stroke();
      }

      function calculateRawHeading(p1, p2) {
        let dx_px = p2.x - p1.x;
        let dy_px = p2.y - p1.y;
        let rad = Math.atan2(dy_px, dx_px);
        let deg = (rad * 180) / Math.PI;
        return deg;
      }

      function getCoordinatesInches(point) {
        let pixelX = point.x - CANVAS_SIZE / 2;
        let pixelY = point.y - CANVAS_SIZE / 2;
        let inchesY = pixelX / PIXELS_PER_INCH;
        let inchesX = pixelY / PIXELS_PER_INCH;
        return { x: inchesX, y: inchesY };
      }

      function generateFormattedOutput(points) {
        if (points.length === 0) {
          outputBox.value =
            "// LÃ¼tfen haritaya tÄ±klayarak baÅŸlangÄ±Ã§ noktasÄ±nÄ± (robotu) yerleÅŸtirin.";
          return;
        }

        let outputText = "";

        for (let i = 0; i < points.length; i++) {
          let currentP = points[i];
          let coords = getCoordinatesInches(currentP);
          let angleFinal = 0;

          if (
            currentP.customHeading !== null &&
            currentP.customHeading !== undefined
          ) {
            angleFinal = currentP.customHeading;
          } else {
            if (points.length > 1) {
              if (i < points.length - 1) {
                angleFinal = calculateRawHeading(currentP, points[i + 1]);
              } else {
                angleFinal = calculateRawHeading(points[i - 1], currentP);
              }
            }
          }

          let xF = Math.round(coords.x * 100) / 100;
          let yF = Math.round(coords.y * 100) / 100;
          let aF = Math.round(angleFinal * 100) / 100;

          if (i === 0) {
            outputText += `chassis.odom_xyt_set(${xF}_in, ${yF}_in, ${aF}_deg);`;
            if (currentP.name && currentP.name.length > 0) {
              outputText += ` // ${currentP.name}`;
            }
            outputText += "\n\nchassis.pid_odom_set({\n";
          } else {
            let ptSpeed = currentP.speed || globalSpeedInput.value;
            let ptDir = currentP.dir || "fwd";

            let lineData = `{${xF}_in, ${yF}_in, ${aF}_deg, ${ptDir}, ${ptSpeed}}`;

            if (i > 1) outputText += "\n";
            outputText += "      " + lineData;

            if (i < points.length - 1) {
              outputText += ",";
            }

            if (currentP.name && currentP.name.length > 0) {
              outputText += ` // ${currentP.name}`;
            }
          }
        }

        if (points.length === 1) {
          outputText += "      // Hareket iÃ§in daha fazla nokta ekleyin...\n";
        }

        outputText += "\n}, true);\nchassis.pid_wait();";
        outputBox.value = outputText;
      }

      function copyToClipboard() {
        outputBox.select();
        document.execCommand("copy");
      }
    </script>
  </body>
</html>
