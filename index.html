<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VEX Path Planner - Pro Editor v4</title>
    <style>
      /* GENEL SAYFA DÜZENİ */
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #1e1e1e;
        color: #ccc;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px;
        margin: 0;
        height: 100vh;
        overflow: hidden;
      }

      h1 {
        color: #fff;
        margin: 5px 0 10px 0;
        font-size: 1.4rem;
      }

      /* ÜST KONTROL BAR */
      .top-controls {
        background: #2d2d2d;
        padding: 8px 20px;
        border-radius: 8px;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 15px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        z-index: 10;
      }

      .top-controls label {
        font-weight: bold;
        color: #fff;
        font-size: 13px;
      }
      .top-controls input[type="number"],
      .top-controls input[type="text"] {
        background: #444;
        border: 1px solid #555;
        color: #fff;
        padding: 4px;
        border-radius: 4px;
        width: 60px;
        text-align: center;
      }
      .top-controls input:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* TOGGLE SWITCH */
      .switch-container {
        display: flex;
        align-items: center;
        gap: 8px;
        background: #383838;
        padding: 4px 12px;
        border-radius: 20px;
      }
      .switch {
        position: relative;
        display: inline-block;
        width: 36px;
        height: 18px;
      }
      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 20px;
      }
      .slider:before {
        position: absolute;
        content: "";
        height: 14px;
        width: 14px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }
      input:checked + .slider {
        background-color: #007bff;
      }
      input:checked + .slider.green {
        background-color: #28a745;
      }
      input:checked + .slider:before {
        transform: translateX(18px);
      }

      /* ANA DÜZEN */
      .main-layout {
        display: flex;
        gap: 15px;
        justify-content: center;
        align-items: flex-start;
        height: calc(100vh - 80px);
      }

      .canvas-wrapper {
        position: relative;
        border: 4px solid #444;
        width: 600px;
        height: 600px;
        flex-shrink: 0;
        cursor: crosshair;
      }
      canvas {
        position: absolute;
        top: 0;
        left: 0;
      }

      .settings-panel {
        width: 240px;
        background-color: #252526;
        border: 1px solid #3e3e42;
        border-radius: 8px;
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        height: 600px;
        box-sizing: border-box;
        overflow-y: auto;
      }
      .settings-panel h3 {
        margin: 0;
        font-size: 1rem;
        color: #ff9f43;
        text-align: center;
        border-bottom: 1px solid #444;
        padding-bottom: 5px;
      }
      .setting-group {
        background: #333;
        padding: 8px;
        border-radius: 6px;
      }
      .setting-group label {
        display: block;
        font-size: 0.85rem;
        color: #aaa;
        margin-bottom: 4px;
      }
      .coord-inputs {
        display: flex;
        gap: 5px;
        align-items: center;
      }
      .coord-inputs input {
        width: 100%;
        background: #222;
        border: 1px solid #555;
        color: #fff;
        padding: 3px;
        text-align: center;
        font-family: monospace;
      }
      .coord-inputs span {
        font-size: 0.8rem;
        color: #888;
      }
      .angle-control {
        display: flex;
        align-items: center;
        gap: 5px;
        margin-bottom: 5px;
      }
      .angle-buttons {
        display: flex;
        gap: 5px;
        margin-top: 5px;
      }
      .angle-buttons button {
        padding: 4px;
        font-size: 0.8rem;
        background-color: #555;
      }
      input[type="range"] {
        width: 100%;
        accent-color: #ff9f43;
        margin: 5px 0;
      }

      .output-panel {
        width: 320px;
        background-color: #2d2d2d;
        padding: 10px;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        height: 600px;
        box-sizing: border-box;
      }
      .tools-menu {
        background: #333;
        padding: 8px;
        border-radius: 5px;
        display: flex;
        gap: 5px;
        justify-content: space-around;
      }
      .tool-btn {
        background: #444;
        font-size: 0.8rem;
        padding: 5px;
      }
      textarea {
        flex-grow: 1;
        background-color: #111;
        color: #569cd6;
        border: 1px solid #555;
        padding: 8px;
        font-family: "Consolas", "Courier New", monospace;
        font-size: 11px;
        white-space: pre;
        resize: none;
      }
      .btn-group {
        display: flex;
        gap: 5px;
      }
      button {
        padding: 8px;
        flex: 1;
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
        border-radius: 4px;
        font-weight: bold;
        transition: 0.2s;
      }
      button:hover {
        background-color: #0056b3;
      }
      button.clear {
        background-color: #dc3545;
      }
      button.clear:hover {
        background-color: #a71d2a;
      }
      button.undo {
        background-color: #ffc107;
        color: #333;
      }
      button.delete-pt {
        background-color: #dc3545;
        color: #fff;
        margin-top: 5px;
        width: 100%;
      }
    </style>
  </head>
  <body>
    <h1>VEX Path Planner - Pro Editor v4</h1>

    <div class="top-controls">
      <div class="switch-container">
        <span style="font-size: 12px; color: #aaa">MOD:</span>
        <label class="switch">
          <input
            type="checkbox"
            id="modeToggle"
            onchange="toggleMode()"
            checked
          />
          <span class="slider"></span>
        </label>
        <span id="modeLabel">Nokta Ekleme</span>
      </div>

      <span style="border-left: 1px solid #555; height: 20px"></span>

      <div class="switch-container">
        <span style="font-size: 12px; color: #aaa">GÖRSEL:</span>
        <label class="switch">
          <input type="checkbox" id="curveToggle" onchange="updateSettings()" />
          <span class="slider green"></span>
        </label>
        <span id="curveLabel">Düz Çizgi</span>
      </div>

      <label for="pointCountInput">Vis.Kalite:</label>
      <input
        type="number"
        id="pointCountInput"
        value="20"
        min="5"
        max="50"
        onchange="updateSettings()"
      />

      <label for="speedInput">Hız:</label>
      <input
        type="text"
        id="speedInput"
        value="DRIVE_SPEED"
        style="width: 80px"
      />
    </div>

    <div class="main-layout">
      <div class="canvas-wrapper">
        <canvas id="fieldCanvas" width="600" height="600"></canvas>
      </div>

      <div class="settings-panel">
        <h3>Nokta Düzenleyici</h3>

        <div
          id="noSelectionMsg"
          style="
            text-align: center;
            color: #666;
            margin-top: 20px;
            font-size: 0.9rem;
          "
        >
          Bir nokta seçili değil.<br /><br />Düzenlemek için haritadan bir
          noktaya tıklayın.
        </div>

        <div id="selectionControls" style="display: none">
          <div class="setting-group">
            <label>Seçili Nokta:</label>
            <span
              id="selectedIndexDisplay"
              style="font-weight: bold; color: #fff"
              >#0</span
            >
          </div>

          <div class="setting-group">
            <label>Konum (X, Y inç):</label>
            <div class="coord-inputs">
              <span>X:</span>
              <input
                type="number"
                id="coordXInput"
                step="0.5"
                onchange="manualCoordChange()"
              />
            </div>
            <div class="coord-inputs" style="margin-top: 5px">
              <span>Y:</span>
              <input
                type="number"
                id="coordYInput"
                step="0.5"
                onchange="manualCoordChange()"
              />
            </div>
          </div>

          <div class="setting-group">
            <label>Açı (Derece):</label>
            <div class="angle-control">
              <input
                type="number"
                id="angleInput"
                value="0"
                min="-180"
                max="180"
                oninput="manualAngleChange(this.value)"
              />
              <button
                onclick="resetAngle()"
                style="padding: 2px; font-size: 10px; width: auto; flex: 0"
              >
                Oto
              </button>
            </div>
            <input
              type="range"
              id="angleSlider"
              min="-180"
              max="180"
              value="0"
              oninput="manualAngleChange(this.value)"
            />

            <div class="angle-buttons">
              <button onclick="rotateAngle(-90)">↺ -90°</button>
              <button onclick="rotateAngle(90)">↻ +90°</button>
            </div>

            <div
              style="
                font-size: 9px;
                color: #777;
                margin-top: 4px;
                text-align: center;
              "
            >
              Sağ:0, Yukarı:-90, Sol:180, Aşağı:90
            </div>
          </div>

          <button class="delete-pt" onclick="deleteSelectedPoint()">
            Noktayı Sil
          </button>
        </div>
      </div>

      <div class="output-panel">
        <h3 style="margin: 0; color: #fff; font-size: 0.9rem">Hızlı Araçlar</h3>
        <div class="tools-menu">
          <button class="tool-btn" onclick="mirrorPath('X')">
            ↔ Yatay Aynala
          </button>
          <button class="tool-btn" onclick="mirrorPath('Y')">
            ↕ Dikey Aynala
          </button>
        </div>

        <h3 style="margin-top: 5px; color: #fff; font-size: 0.9rem">
          Kod Çıktısı
        </h3>
        <textarea id="outputBox" readonly>// Kod buraya gelecek...</textarea>

        <div class="btn-group">
          <button onclick="copyToClipboard()">Kopyala</button>
          <button class="undo" onclick="undoLastPoint()" id="undoBtn">
            Geri Al
          </button>
          <button class="clear" onclick="clearCanvas()">Tümü Sil</button>
        </div>
      </div>
    </div>

    <script>
      // --- DEĞİŞKENLER ---
      const canvas = document.getElementById("fieldCanvas");
      const ctx = canvas.getContext("2d");
      const outputBox = document.getElementById("outputBox");
      const pointCountInput = document.getElementById("pointCountInput");
      const speedInput = document.getElementById("speedInput");
      const modeLabel = document.getElementById("modeLabel");
      const curveToggle = document.getElementById("curveToggle");
      const curveLabel = document.getElementById("curveLabel");

      const noSelectionMsg = document.getElementById("noSelectionMsg");
      const selectionControls = document.getElementById("selectionControls");
      const selectedIndexDisplay = document.getElementById(
        "selectedIndexDisplay"
      );
      const coordXInput = document.getElementById("coordXInput");
      const coordYInput = document.getElementById("coordYInput");
      const angleInput = document.getElementById("angleInput");
      const angleSlider = document.getElementById("angleSlider");

      const bgImage = new Image();
      bgImage.src = "field.png";

      const FIELD_SIZE_INCHES = 144;
      const CANVAS_SIZE = 600;
      const PIXELS_PER_INCH = CANVAS_SIZE / FIELD_SIZE_INCHES;
      const OFFSET_X = -48;
      const OFFSET_Y = 0;

      let rawPoints = [];
      let isPointMode = true;
      let isDrawing = false;
      let selectedPointIndex = -1;

      bgImage.onload = function () {
        drawScreen();
      };

      // --- MOD YÖNETİMİ ---
      function toggleMode() {
        const toggle = document.getElementById("modeToggle");
        isPointMode = toggle.checked;

        if (isPointMode) {
          modeLabel.innerText = "Nokta Ekleme";
          canvas.style.cursor = "default";
          document.getElementById("undoBtn").style.display = "block";
        } else {
          modeLabel.innerText = "Serbest Çizim";
          canvas.style.cursor = "crosshair";
          selectedPointIndex = -1;
          updateSelectionUI();
          document.getElementById("undoBtn").style.display = "none";
        }
        clearCanvas();
      }

      function updateSettings() {
        if (curveToggle.checked) {
          curveLabel.innerText = "Akıllı Eğri";
          curveLabel.style.color = "#28a745";
        } else {
          curveLabel.innerText = "Düz Çizgi";
          curveLabel.style.color = "#aaa";
        }

        if (rawPoints.length > 0) processPath();
      }

      // --- MOUSE EVENTLERİ ---
      canvas.addEventListener("mousedown", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        let clickedIndex = -1;
        for (let i = rawPoints.length - 1; i >= 0; i--) {
          const dist = Math.hypot(rawPoints[i].x - mx, rawPoints[i].y - my);
          if (dist < 15) {
            clickedIndex = i;
            break;
          }
        }

        if (clickedIndex !== -1) {
          selectedPointIndex = clickedIndex;
          updateSelectionUI();
          drawScreen();
          return;
        } else {
          if (selectedPointIndex !== -1) {
            selectedPointIndex = -1;
            updateSelectionUI();
            drawScreen();
            return;
          }
        }

        if (isPointMode) {
          addRawPoint(mx, my);
          selectedPointIndex = rawPoints.length - 1;
          updateSelectionUI();
          drawScreen();
          processPath();
        } else {
          isDrawing = true;
          rawPoints = [];
          selectedPointIndex = -1;
          addRawPoint(mx, my);
          drawScreen();
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        if (!isPointMode && isDrawing) {
          const rect = canvas.getBoundingClientRect();
          addRawPoint(e.clientX - rect.left, e.clientY - rect.top);
          drawScreen();
          drawRawPath(rawPoints, false);
        }
      });

      canvas.addEventListener("mouseup", () => {
        if (!isPointMode && isDrawing) {
          isDrawing = false;
          processPath();
        }
      });

      // --- NOKTA İŞLEMLERİ ---
      function addRawPoint(x, y) {
        rawPoints.push({ x, y, customHeading: null });
      }

      function deleteSelectedPoint() {
        if (selectedPointIndex !== -1) {
          rawPoints.splice(selectedPointIndex, 1);
          selectedPointIndex = -1;
          updateSelectionUI();
          drawScreen();
          processPath();
        }
      }

      function undoLastPoint() {
        if (rawPoints.length > 0) {
          rawPoints.pop();
          selectedPointIndex = -1;
          updateSelectionUI();
          drawScreen();
          processPath();
        }
      }

      function clearCanvas() {
        rawPoints = [];
        selectedPointIndex = -1;
        updateSelectionUI();
        drawScreen();
        outputBox.value = "// Nokta ekleyin...";
      }

      function mirrorPath(axis) {
        if (rawPoints.length === 0) return;
        const cx = CANVAS_SIZE / 2;
        const cy = CANVAS_SIZE / 2;

        rawPoints.forEach((p) => {
          if (axis === "X") {
            let distFromCenter = p.x - cx;
            p.x = cx - distFromCenter;
            if (p.customHeading !== null) {
              let a = p.customHeading;
              if (a > 0) p.customHeading = 180 - a;
              else p.customHeading = -180 - a;
              while (p.customHeading > 180) p.customHeading -= 360;
              while (p.customHeading < -180) p.customHeading += 360;
            }
          } else if (axis === "Y") {
            let distFromCenter = p.y - cy;
            p.y = cy - distFromCenter;
            if (p.customHeading !== null) {
              p.customHeading = -p.customHeading;
            }
          }
        });
        drawScreen();
        processPath();
        if (selectedPointIndex !== -1) updateSelectionUI();
      }

      // --- UI GÜNCELLEME ---
      function updateSelectionUI() {
        if (selectedPointIndex !== -1) {
          noSelectionMsg.style.display = "none";
          selectionControls.style.display = "block";

          const p = rawPoints[selectedPointIndex];
          const coords = getCoordinatesInches(p);

          selectedIndexDisplay.innerText = "#" + (selectedPointIndex + 1);
          coordXInput.value = coords.x.toFixed(2);
          coordYInput.value = coords.y.toFixed(2);

          if (p.customHeading !== null) {
            angleInput.value = p.customHeading;
            angleSlider.value = p.customHeading;
          } else {
            angleInput.value = "";
            angleInput.placeholder = "Oto";
            angleSlider.value = 0;
          }
        } else {
          noSelectionMsg.style.display = "block";
          selectionControls.style.display = "none";
        }
      }

      function manualCoordChange() {
        if (selectedPointIndex === -1) return;
        let newXInches = parseFloat(coordXInput.value);
        let newYInches = parseFloat(coordYInput.value);
        if (isNaN(newXInches) || isNaN(newYInches)) return;

        let pX = (newXInches + OFFSET_X) * PIXELS_PER_INCH + CANVAS_SIZE / 2;
        let pY = CANVAS_SIZE / 2 - (newYInches + OFFSET_Y) * PIXELS_PER_INCH;

        rawPoints[selectedPointIndex].x = pX;
        rawPoints[selectedPointIndex].y = pY;
        drawScreen();
        processPath();
      }

      function manualAngleChange(val) {
        if (selectedPointIndex !== -1) {
          rawPoints[selectedPointIndex].customHeading = parseFloat(val);
          angleInput.value = val;
          angleSlider.value = val;
          drawScreen();
          processPath();
        }
      }

      function rotateAngle(delta) {
        if (selectedPointIndex !== -1) {
          let current = rawPoints[selectedPointIndex].customHeading;
          if (current === null) current = 0;
          let newVal = current + delta;
          while (newVal > 180) newVal -= 360;
          while (newVal < -180) newVal += 360;
          rawPoints[selectedPointIndex].customHeading = newVal;
          updateSelectionUI();
          drawScreen();
          processPath();
        }
      }

      function resetAngle() {
        if (selectedPointIndex !== -1) {
          rawPoints[selectedPointIndex].customHeading = null;
          updateSelectionUI();
          drawScreen();
          processPath();
        }
      }

      // --- AKILLI HERMITE SPLINE ALGORİTMASI ---
      // Açıyı (Tangent) hesaba katan yeni eğri fonksiyonu
      function getHermiteSplinePoints(points, segments) {
        if (points.length < 2) return points;
        let splinePoints = [];

        // 1. Her nokta için Tangent (Yön/Şiddet) vektörünü hesapla
        let tangents = [];
        for (let i = 0; i < points.length; i++) {
          let tX, tY;
          let magnitude = 0;

          // Şiddet (Magnitude) hesabı: Komşular arası mesafeye göre
          // Eğer çok kısa mesafede büyük dönüş varsa 'loop' olmasın diye kısıtla.
          let prev = points[i - 1] || points[i];
          let next = points[i + 1] || points[i];
          let dist = Math.hypot(next.x - prev.x, next.y - prev.y);
          if (i === 0 || i === points.length - 1) dist *= 2; // Uç noktalarda biraz daha güç ver
          magnitude = dist * 0.5; // Catmull-Rom standardı 0.5'tir

          // Yön Hesabı
          if (points[i].customHeading !== null) {
            // KULLANICI AÇISI VARSA: Onu kullan!
            // VEX Açısı: 0=Sağ, -90=Yukarı.
            // Math Radyan: Angle * PI / 180.
            // Canvas Y TERS olduğu için Sinüs'ü ters alacağız.
            // VEX -90 -> Math 90. Cos(90)=0, Sin(90)=1. Canvas(0, -1) -> Yukarı.
            let angleDeg = -points[i].customHeading;
            let rad = (angleDeg * Math.PI) / 180;
            tX = Math.cos(rad) * magnitude;
            tY = -Math.sin(rad) * magnitude; // Y ekseni düzeltmesi
          } else {
            // OTOMATİK: Komşular arası farka bak (Catmull-Rom usulü)
            tX = (next.x - prev.x) * 0.5;
            tY = (next.y - prev.y) * 0.5;
          }
          tangents.push({ x: tX, y: tY });
        }

        // 2. Noktalar arasını interpolasyon yap (Cubic Hermite)
        for (let i = 0; i < points.length - 1; i++) {
          let p0 = points[i];
          let p1 = points[i + 1];
          let m0 = tangents[i];
          let m1 = tangents[i + 1];

          for (let t = 0; t <= segments; t++) {
            let s = t / segments;
            let s2 = s * s;
            let s3 = s2 * s;

            // Hermite Basis Functions
            let h1 = 2 * s3 - 3 * s2 + 1; // p0 katsayısı
            let h2 = s3 - 2 * s2 + s; // m0 katsayısı
            let h3 = -2 * s3 + 3 * s2; // p1 katsayısı
            let h4 = s3 - s2; // m1 katsayısı

            let x = h1 * p0.x + h2 * m0.x + h3 * p1.x + h4 * m1.x;
            let y = h1 * p0.y + h2 * m0.y + h3 * p1.y + h4 * m1.y;

            splinePoints.push({ x: x, y: y });
          }
        }
        return splinePoints;
      }

      // --- ÇİZİM ---
      function drawScreen() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (bgImage.complete && bgImage.naturalHeight !== 0) {
          ctx.drawImage(bgImage, 0, 0, CANVAS_SIZE, CANVAS_SIZE);
        } else {
          ctx.fillStyle = "#333";
          ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
        }
        drawGrid();
        drawOriginPoint();

        let visualPoints = rawPoints;
        let useCurveColor = false;

        // Görselleştirme: Hermite Spline Kullan
        if (curveToggle.checked && rawPoints.length > 1) {
          let segments = parseInt(pointCountInput.value) || 20;
          visualPoints = getHermiteSplinePoints(rawPoints, segments);
          useCurveColor = true;
        }

        if (isPointMode || (!isDrawing && rawPoints.length > 0)) {
          if (rawPoints.length > 1) drawRawPath(visualPoints, useCurveColor);

          for (let i = 0; i < rawPoints.length; i++) {
            drawFancyPoint(rawPoints[i], i === selectedPointIndex);
          }
        } else if (isDrawing) {
          drawRawPath(rawPoints, false);
        }
      }

      function drawFancyPoint(p, isSelected) {
        ctx.beginPath();
        ctx.fillStyle = isSelected
          ? "rgba(255, 159, 67, 1.0)"
          : "rgba(255, 159, 67, 0.6)";
        ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
        ctx.fill();
        if (isSelected) {
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        if (p.customHeading !== null) {
          let angleDeg = -p.customHeading;
          const angleRad = (angleDeg * Math.PI) / 180;
          const lineLen = 20;
          ctx.beginPath();
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(
            p.x + Math.cos(angleRad) * lineLen,
            p.y - Math.sin(angleRad) * lineLen
          );
          ctx.stroke();
        }
      }

      function drawGrid() {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
        ctx.lineWidth = 1;
        const tileSize = 24 * PIXELS_PER_INCH;
        for (let i = 1; i < 6; i++) {
          ctx.beginPath();
          ctx.moveTo(i * tileSize, 0);
          ctx.lineTo(i * tileSize, CANVAS_SIZE);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, i * tileSize);
          ctx.lineTo(CANVAS_SIZE, i * tileSize);
          ctx.stroke();
        }
      }

      function drawOriginPoint() {
        const ox = CANVAS_SIZE / 2 + OFFSET_X * PIXELS_PER_INCH;
        const oy = CANVAS_SIZE / 2 - OFFSET_Y * PIXELS_PER_INCH;
        ctx.fillStyle = "yellow";
        ctx.beginPath();
        ctx.arc(ox, oy, 4, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawRawPath(pts, isCurved) {
        if (pts.length < 2) return;
        ctx.beginPath();
        ctx.strokeStyle = isCurved ? "#28a745" : "cyan";
        ctx.lineWidth = 2;
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
        ctx.stroke();
      }

      // --- KOD ÜRETİMİ ---
      function processPath() {
        if (rawPoints.length < 1) return;
        // Çıktı yine ana noktalardan oluşur
        generateFormattedOutput(rawPoints);
      }

      function getCoordinatesInches(point) {
        let pixelDX = point.x - CANVAS_SIZE / 2;
        let pixelDY = CANVAS_SIZE / 2 - point.y;
        return {
          x: pixelDX / PIXELS_PER_INCH - OFFSET_X,
          y: pixelDY / PIXELS_PER_INCH - OFFSET_Y,
        };
      }

      function calculateRawHeading(p1, p2) {
        const c1 = getCoordinatesInches(p1);
        const c2 = getCoordinatesInches(p2);
        const dy = c2.y - c1.y;
        const dx = c2.x - c1.x;
        let mathDeg = (Math.atan2(dy, dx) * 180) / Math.PI;
        return -mathDeg;
      }

      function generateFormattedOutput(points) {
        const speedVar = speedInput.value;
        let outputText = "chassis.pid_odom_set({\n";

        let continuousAngle = 0;
        let previousRawAngle = 0;

        for (let i = 0; i < points.length; i++) {
          let currentP = points[i];
          let coords = getCoordinatesInches(currentP);
          let angleFinal = 0;

          if (
            currentP.customHeading !== null &&
            currentP.customHeading !== undefined
          ) {
            angleFinal = currentP.customHeading;
            continuousAngle = angleFinal;
            previousRawAngle = angleFinal;
          } else {
            let currentRawAngle = 0;
            if (points.length > 1) {
              if (i < points.length - 1) {
                currentRawAngle = calculateRawHeading(currentP, points[i + 1]);
              } else {
                currentRawAngle = calculateRawHeading(points[i - 1], currentP);
              }
            }

            if (i === 0) {
              continuousAngle = currentRawAngle;
            } else {
              let delta = currentRawAngle - previousRawAngle;
              while (delta > 180) delta -= 360;
              while (delta < -180) delta += 360;
              continuousAngle += delta;
            }
            angleFinal = continuousAngle;
            previousRawAngle = currentRawAngle;
          }

          let xF = Math.round(coords.x * 100) / 100;
          let yF = Math.round(coords.y * 100) / 100;
          let aF = Math.round(angleFinal * 100) / 100;

          const lineData = `{${xF}_in, ${yF}_in, ${aF}_deg, fwd, ${speedVar}}`;
          outputText += (i === 0 ? "      " : ",\n      ") + lineData;
        }

        outputText += "\n}, true);";
        outputBox.value = outputText;
      }

      function copyToClipboard() {
        outputBox.select();
        document.execCommand("copy");
      }
    </script>
  </body>
</html>
